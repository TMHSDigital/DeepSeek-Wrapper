<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <title>DeepSeek Chat</title>
    <link rel="stylesheet" href="/static/style.css">
    <script>
    function scrollChat() {
        var chat = document.getElementById('chat-history');
        if (chat) chat.scrollTop = chat.scrollHeight;
    }
    function focusInput() {
        var input = document.getElementById('user_message');
        if (input) input.focus();
    }
    window.onload = function() {
        scrollChat();
        focusInput();
    };
    function handleKey(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            sendChat();
        }
    }
    function sendChat() {
        var btn = document.getElementById('send-btn');
        var input = document.getElementById('user_message');
        var sendingStatus = document.getElementById('sending-status');
        var chatHistory = document.getElementById('chat-history');
        
        if (!input.value.trim()) return;
        
        // Disable button and show sending indicator
        if (btn) btn.disabled = true;
        if (sendingStatus) sendingStatus.style.display = 'block';
        
        // Create form data for the request
        const formData = new FormData();
        formData.append('user_message', input.value);
        
        // Clear input immediately
        const userMessage = input.value;
        input.value = '';
        
        // Create and handle the EventSource for streaming
        const eventSource = new EventSource(`/chat/stream?_=${Date.now()}`, {
            withCredentials: true
        });
        
        let assistantMsgElement = null;
        
        eventSource.addEventListener('message', function(e) {
            try {
                const data = JSON.parse(e.data);
                
                switch(data.type) {
                    case 'user_msg_received':
                        // Add user message to chat UI
                        const userMsgHtml = `
                            <div class="msg-row user">
                                <div class="avatar">
                                    <span class="avatar-letter">U</span>
                                </div>
                                <div class="bubble user-msg">
                                    <span class="role">User</span>
                                    <span class="timestamp">${data.message.timestamp}</span><br>
                                    <span class="content" style="display:block;">${data.message.content}</span>
                                    <div class="message-actions">
                                        <button class="action-btn copy-btn" onclick="copyMessage(this)">
                                            <span class="action-tooltip">Copy</span>
                                            üìã
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `;
                        chatHistory.insertAdjacentHTML('beforeend', userMsgHtml);
                        scrollChat();
                        break;
                        
                    case 'assistant_msg_start':
                        // Create the assistant message container but with empty content
                        const assistantMsgHtml = `
                            <div class="msg-row assistant">
                                <div class="avatar">
                                    <span class="avatar-letter">A</span>
                                </div>
                                <div class="bubble assistant-msg">
                                    <span class="role">Assistant</span>
                                    <span class="timestamp">${data.message.timestamp}</span><br>
                                    <span class="content streaming-content" style="display:block;"></span>
                                    <div class="message-actions">
                                        <button class="action-btn copy-btn" onclick="copyMessage(this)">
                                            <span class="action-tooltip">Copy</span>
                                            üìã
                                        </button>
                                    </div>
                                </div>
                            </div>
                        `;
                        chatHistory.insertAdjacentHTML('beforeend', assistantMsgHtml);
                        assistantMsgElement = chatHistory.querySelector('.streaming-content');
                        scrollChat();
                        break;
                        
                    case 'content_chunk':
                        // Append the chunk to the content
                        if (assistantMsgElement) {
                            const chunk = data.chunk;
                            
                            // Convert markdown on-the-fly (simplified)
                            // Full markdown rendering would be more complex and might cause flickering
                            // For better results, we should accumulate content and render after streaming completes
                            if (assistantMsgElement.innerHTML === '') {
                                assistantMsgElement.innerHTML = chunk;
                            } else {
                                assistantMsgElement.innerHTML += chunk;
                            }
                            
                            scrollChat();
                        }
                        break;
                        
                    case 'complete':
                        // Streaming is complete, close the connection
                        eventSource.close();
                        if (assistantMsgElement) {
                            // Re-render the complete message with proper markdown
                            const markdownContent = renderMarkdown(data.message.content);
                            assistantMsgElement.innerHTML = markdownContent;
                            assistantMsgElement.classList.remove('streaming-content');
                        }
                        sendingStatus.style.display = 'none';
                        btn.disabled = false;
                        break;
                        
                    case 'error':
                        // Handle error
                        eventSource.close();
                        const errorBanner = document.createElement('div');
                        errorBanner.className = 'error-banner';
                        errorBanner.textContent = data.error;
                        chatHistory.parentNode.insertBefore(errorBanner, chatHistory.nextSibling);
                        
                        sendingStatus.style.display = 'none';
                        btn.disabled = false;
                        break;
                }
            } catch (error) {
                console.error("Error processing event:", error);
            }
        });
        
        eventSource.addEventListener('error', function(e) {
            console.error('EventSource error:', e);
            eventSource.close();
            sendingStatus.style.display = 'none';
            btn.disabled = false;
            
            // Show error message
            const errorBanner = document.createElement('div');
            errorBanner.className = 'error-banner';
            errorBanner.textContent = "Connection error. Please try again.";
            chatHistory.parentNode.insertBefore(errorBanner, chatHistory.nextSibling);
        });
    }
    
    // Simplified markdown renderer for streaming chunks
    function renderMarkdown(text) {
        // Basic markdown formatting (very simplified)
        // Replace with a proper markdown library in production
        text = text
            // Code blocks
            .replace(/```(\w*)([\s\S]*?)```/g, '<pre><code>$2</code></pre>')
            // Bold
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            // Italic
            .replace(/\*(.*?)\*/g, '<em>$1</em>')
            // Links
            .replace(/\[(.*?)\]\((.*?)\)/g, '<a href="$2">$1</a>')
            // Line breaks
            .replace(/\n/g, '<br>');
            
        return text;
    }
    </script>
</head>
<body>
    <div class="container">
        <h1>DeepSeek Chat</h1>
        <button id="theme-toggle" class="theme-toggle" title="Toggle theme (Alt+T)" aria-label="Toggle dark/light theme">‚òÄÔ∏è</button>
        <button id="export-btn" class="export-btn" title="Export conversation (Alt+E)" aria-label="Export conversation">üì• Export</button>
        <form id="chat-form" method="post" onsubmit="sendChat(); return false;">
            <textarea id="user_message" name="user_message" placeholder="Type your message... (Enter to send, Shift+Enter for newline)" required rows="2" onkeydown="handleKey(event)" aria-label="Message input"></textarea>
            <button id="send-btn" type="submit" {% if loading %}disabled{% endif %} aria-label="Send message">Send</button>
            <button type="button" onclick="document.getElementById('reset-form').submit();" class="reset-btn" aria-label="Reset conversation">Reset</button>
        </form>
        <form id="reset-form" method="post" action="/reset" style="display:none;"></form>
        <form id="upload-form" enctype="multipart/form-data" style="margin-top:10px;">
            <input type="file" id="file-input" name="file" accept="image/*,.pdf,.txt,.doc,.docx" />
            <button id="upload-btn" type="submit">Upload File</button>
            <progress id="upload-progress" value="0" max="100" style="display:none;width:120px;"></progress>
            <span id="upload-status" style="margin-left:10px;"></span>
            <div id="image-preview" style="margin-top:10px;"></div>
        </form>
        <div id="upload-area" class="upload-area">
            <div class="upload-area-icon">üì§</div>
            <div class="upload-area-text">Drop files here to upload</div>
        </div>
        <div class="chat-container">
            <div id="chat-history" class="chat-history">
                {% if messages %}
                    {% for msg in messages %}
                        <div class="msg-row {{ msg.role }}">
                            <div class="avatar">
                                <span class="avatar-letter">{% if msg.role == 'user' %}U{% else %}A{% endif %}</span>
                            </div>
                            <div class="bubble {{ msg.role }}-msg">
                                <span class="role">{{ msg.role.title() }}</span>
                                <span class="timestamp">{{ msg.timestamp }}</span><br>
                                <span class="content" style="display:block;">{{ msg.content_html|safe }}</span>
                                <div class="message-actions">
                                    <button class="action-btn copy-btn" onclick="copyMessage(this)">
                                        <span class="action-tooltip">Copy</span>
                                        üìã
                                    </button>
                                </div>
                            </div>
                        </div>
                    {% endfor %}
                {% else %}
                    <div class="empty-chat">
                        <div class="empty-chat-icon">üí¨</div>
                        <h2>Welcome to DeepSeek Chat</h2>
                        <p>Type a message below to start a conversation with the AI assistant. You can also upload files or paste images to share them.</p>
                    </div>
                {% endif %}
                {% if loading %}
                    <div class="msg-row assistant">
                        <div class="avatar">
                            <span class="avatar-letter">A</span>
                        </div>
                        <div class="bubble assistant-msg loading-bubble">
                            <div class="typing-indicator">
                                <span class="typing-dot"></span>
                                <span class="typing-dot"></span>
                                <span class="typing-dot"></span>
                            </div>
                        </div>
                    </div>
                {% endif %}
                <div id="sending-status" class="sending-indicator" style="display:none;"></div>
            </div>
            <div id="scroll-bottom" class="scroll-bottom-btn" title="Scroll to bottom">‚Üì</div>
        </div>
        {% if error %}
        <div class="error-banner">{{ error }}</div>
        {% endif %}
    </div>
    <script>
    const uploadForm = document.getElementById('upload-form');
    const uploadBtn = document.getElementById('upload-btn');
    const uploadProgress = document.getElementById('upload-progress');
    const uploadStatus = document.getElementById('upload-status');
    const imagePreview = document.getElementById('image-preview');
    uploadForm.onsubmit = async function(e) {
        e.preventDefault();
        const input = document.getElementById('file-input');
        if (!input.files.length) { uploadStatus.textContent = 'No file selected'; return; }
        const file = input.files[0];
        const formData = new FormData();
        formData.append('file', file);
        uploadBtn.disabled = true;
        uploadStatus.textContent = 'Uploading...';
        uploadProgress.style.display = 'inline-block';
        uploadProgress.value = 0;
        imagePreview.innerHTML = '';
        // Use XMLHttpRequest for progress
        const xhr = new XMLHttpRequest();
        xhr.open('POST', '/upload', true);
        xhr.upload.onprogress = function(e) {
            if (e.lengthComputable) {
                uploadProgress.value = (e.loaded / e.total) * 100;
            }
        };
        xhr.onload = function() {
            uploadBtn.disabled = false;
            uploadProgress.style.display = 'none';
            if (xhr.status === 200) {
                const data = JSON.parse(xhr.responseText);
                uploadStatus.textContent = 'Uploaded: ' + data.filename;
                if (data.content_type.startsWith('image/')) {
                    const url = '/uploads/' + data.filename;
                    imagePreview.innerHTML = `<img src="${url}" alt="${data.filename}" style="max-width:200px;max-height:120px;" />`;
                }
            } else {
                uploadStatus.textContent = 'Upload failed';
            }
            input.value = '';
        };
        xhr.onerror = function() {
            uploadBtn.disabled = false;
            uploadProgress.style.display = 'none';
            uploadStatus.textContent = 'Upload failed';
        };
        xhr.send(formData);
    };
    // Image paste support
    document.getElementById('user_message').addEventListener('paste', async function(e) {
        const items = e.clipboardData.items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                const file = items[i].getAsFile();
                const formData = new FormData();
                formData.append('file', file);
                uploadBtn.disabled = true;
                uploadStatus.textContent = 'Uploading pasted image...';
                uploadProgress.style.display = 'inline-block';
                uploadProgress.value = 0;
                imagePreview.innerHTML = '';
                const xhr = new XMLHttpRequest();
                xhr.open('POST', '/upload', true);
                xhr.upload.onprogress = function(e) {
                    if (e.lengthComputable) {
                        uploadProgress.value = (e.loaded / e.total) * 100;
                    }
                };
                xhr.onload = function() {
                    uploadBtn.disabled = false;
                    uploadProgress.style.display = 'none';
                    if (xhr.status === 200) {
                        const data = JSON.parse(xhr.responseText);
                        uploadStatus.textContent = 'Image pasted and uploaded: ' + data.filename;
                        if (data.content_type.startsWith('image/')) {
                            const url = '/uploads/' + data.filename;
                            imagePreview.innerHTML = `<img src="${url}" alt="${data.filename}" style="max-width:200px;max-height:120px;" />`;
                        }
                    } else {
                        uploadStatus.textContent = 'Upload failed';
                    }
                };
                xhr.onerror = function() {
                    uploadBtn.disabled = false;
                    uploadProgress.style.display = 'none';
                    uploadStatus.textContent = 'Upload failed';
                };
                xhr.send(formData);
                e.preventDefault();
            }
        }
    });
    // Reset the sending indicator on page load (response received)
    window.addEventListener('DOMContentLoaded', function() {
        var sendingStatus = document.getElementById('sending-status');
        if (sendingStatus) sendingStatus.style.display = 'none';
    });
    const chatHistory = document.getElementById('chat-history');
    const scrollBottomBtn = document.getElementById('scroll-bottom');
    
    // Show/hide scroll button based on scroll position
    chatHistory.addEventListener('scroll', function() {
        const isScrolledUp = chatHistory.scrollTop < chatHistory.scrollHeight - chatHistory.clientHeight - 50;
        if (isScrolledUp) {
            scrollBottomBtn.classList.add('visible');
        } else {
            scrollBottomBtn.classList.remove('visible');
        }
    });
    
    // Scroll to bottom when button is clicked
    scrollBottomBtn.addEventListener('click', function() {
        chatHistory.scrollTop = chatHistory.scrollHeight;
    });
    
    // Scroll to bottom on load
    function scrollChat() {
        if (chatHistory) chatHistory.scrollTop = chatHistory.scrollHeight;
        
        // Check if we need to show the scroll button
        const isScrolledUp = chatHistory.scrollTop < chatHistory.scrollHeight - chatHistory.clientHeight - 50;
        if (isScrolledUp) {
            scrollBottomBtn.classList.add('visible');
        }
    }
    // Copy message content
    function copyMessage(button) {
        const content = button.closest('.bubble').querySelector('.content').innerText;
        navigator.clipboard.writeText(content).then(function() {
            // Show temporary success indicator
            const tooltip = button.querySelector('.action-tooltip');
            tooltip.textContent = 'Copied!';
            setTimeout(function() {
                tooltip.textContent = 'Copy';
            }, 2000);
        }).catch(function(err) {
            console.error('Could not copy text: ', err);
        });
    }
    // Theme toggle
    const themeToggle = document.getElementById('theme-toggle');
    const htmlElement = document.documentElement;
    
    // Check for saved theme preference or use preferred color scheme
    const savedTheme = localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
    setTheme(savedTheme);
    
    themeToggle.addEventListener('click', function() {
        const currentTheme = htmlElement.getAttribute('data-theme');
        const newTheme = currentTheme === 'light' ? 'dark' : 'light';
        setTheme(newTheme);
        localStorage.setItem('theme', newTheme);
    });
    
    function setTheme(theme) {
        htmlElement.setAttribute('data-theme', theme);
        themeToggle.textContent = theme === 'light' ? '‚òÄÔ∏è' : 'üåô';
        themeToggle.title = theme === 'light' ? 'Switch to dark mode' : 'Switch to light mode';
    }
    // Add JavaScript for drag-and-drop and export functionality
    // Drag and drop file upload
    const uploadArea = document.getElementById('upload-area');
    const fileInput = document.getElementById('file-input');
    
    // Show upload area when dragging over the page
    document.addEventListener('dragover', function(e) {
        e.preventDefault();
        uploadArea.classList.add('visible');
    });
    
    document.addEventListener('dragleave', function(e) {
        if (!e.relatedTarget || e.relatedTarget.tagName === 'HTML') {
            uploadArea.classList.remove('visible');
        }
    });
    
    // Handle drop
    uploadArea.addEventListener('dragover', function(e) {
        e.preventDefault();
        this.classList.add('drag-over');
    });
    
    uploadArea.addEventListener('dragleave', function(e) {
        this.classList.remove('drag-over');
    });
    
    uploadArea.addEventListener('drop', function(e) {
        e.preventDefault();
        this.classList.remove('drag-over');
        this.classList.remove('visible');
        
        if (e.dataTransfer.files.length) {
            fileInput.files = e.dataTransfer.files;
            // Trigger the upload process
            const event = new Event('change');
            fileInput.dispatchEvent(event);
            document.getElementById('upload-form').requestSubmit();
        }
    });
    
    // Click on upload area to select files
    uploadArea.addEventListener('click', function() {
        fileInput.click();
    });
    
    // Export conversation
    document.getElementById('export-btn').addEventListener('click', function() {
        const messages = Array.from(document.querySelectorAll('.msg-row'));
        let text = '# DeepSeek Chat Export\n\n';
        
        messages.forEach(msg => {
            const role = msg.querySelector('.role').textContent;
            const content = msg.querySelector('.content').textContent;
            const time = msg.querySelector('.timestamp').textContent;
            
            text += `## ${role} (${time})\n\n${content}\n\n`;
        });
        
        // Create download link
        const blob = new Blob([text], { type: 'text/markdown' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `deepseek-chat-export-${new Date().toISOString().slice(0, 10)}.md`;
        a.click();
        
        // Clean up
        URL.revokeObjectURL(url);
    });
    
    // Add keyboard shortcut handling
    document.addEventListener('keydown', function(e) {
        // Alt+T for theme toggle
        if (e.altKey && e.key === 't') {
            e.preventDefault();
            document.getElementById('theme-toggle').click();
        }
        
        // Alt+E for export
        if (e.altKey && e.key === 'e') {
            e.preventDefault();
            document.getElementById('export-btn').click();
        }
        
        // Alt+U to focus upload
        if (e.altKey && e.key === 'u') {
            e.preventDefault();
            document.getElementById('file-input').focus();
        }
        
        // Alt+S to focus on message input
        if (e.altKey && e.key === 's') {
            e.preventDefault();
            document.getElementById('user_message').focus();
        }
        
        // Escape to dismiss the upload area if visible
        if (e.key === 'Escape') {
            const uploadArea = document.getElementById('upload-area');
            if (uploadArea.classList.contains('visible')) {
                uploadArea.classList.remove('visible');
            }
        }
    });
    
    // Add focus indicator for keyboard navigation
    document.addEventListener('keyup', function(e) {
        if (e.key === 'Tab') {
            document.body.classList.add('keyboard-nav');
        }
    });
    
    document.addEventListener('mousedown', function() {
        document.body.classList.remove('keyboard-nav');
    });
    </script>
</body>
</html> 